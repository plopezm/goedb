package dialect

import (
	"errors"
	"reflect"
	"strconv"

	"github.com/plopezm/goedb/database/dialect/specifics"
	"github.com/plopezm/goedb/database/models"
)

//SQLDialect is the implementation of Transient SQL as Dialect
type SQLDialect struct {
	Models    map[string]models.Table
	Specifics specifics.Specifics
}

//GetSQLDialectInstance returns the standard SQL dialect with the some small modifications required
func GetSQLDialectInstance(driverSpecifics string) (dialect *SQLDialect) {
	dialect = new(SQLDialect)
	dialect.Models = make(map[string]models.Table)
	switch driverSpecifics {
	case "sqlite3":
		dialect.Specifics = new(specifics.SQLiteSpecifics)
	case "postgres", "pgx":
		dialect.Specifics = new(specifics.PostgresSpecifics)
	default:
		dialect.Specifics = new(specifics.SQLiteSpecifics)
	}
	return dialect
}

//GetModel returns the stored model
func (dialect *SQLDialect) GetModel(name string) (models.Table, bool) {
	model, ok := dialect.Models[name]
	return model, ok
}

//SetModel stores a new model
func (dialect *SQLDialect) SetModel(name string, table models.Table) {
	dialect.Models[name] = table
}

//DeleteModel removes a existing model
func (dialect *SQLDialect) DeleteModel(name string) {
	delete(dialect.Models, name)
}

//Create generates the SQL CREATE TABLE using a goedb table
func (dialect *SQLDialect) Create(table models.Table) string {
	columns := ""
	pksFound := ""
	constraints := ""

	for _, value := range table.Columns {
		columnModel, pksColModel, constModel, err := dialect.Specifics.GetSQLCreateTableColumn(value)
		if err != nil {
			continue
		}
		columns += columnModel
		pksFound += pksColModel
		constraints += constModel
	}

	if len(pksFound) > 0 {
		pksFound = pksFound[:len(pksFound)-1]
		constraints += ", PRIMARY KEY (" + pksFound + ")"
	}

	lastColumnIndex := len(columns)
	sqlquery := "CREATE TABLE " + table.Name + " (" + columns[:lastColumnIndex-1] + constraints + ")"
	return sqlquery
}

//Insert generates the required sql sentence to insert the instance value
func (dialect *SQLDialect) Insert(table models.Table, instance interface{}) (string, error) {
	columns, values, err := getColumnsAndValues(table, instance)
	if err != nil {
		return "", err
	}
	//sql := "INSERT INTO " + table.Name + " (" + columns + ") values(" + values + ")"
	sql := "INSERT INTO " + table.Name + " ("
	for _, column := range columns {
		sql += column + ","
	}
	sql = sql[:len(sql)-1]
	sql += ") values("
	for _, value := range values {
		sql += value + ","
	}
	sql = sql[:len(sql)-1]
	sql += ")"
	return sql, nil
}

//First returns the TransientSQL sentence depending on the table and the instance
func (dialect *SQLDialect) First(table models.Table, where string, instance interface{}) (string, error) {
	sql, relationContraints, err := generateSQLQuery(table, dialect.Models)

	if err != nil {
		return "", err
	}

	if where == "" {
		pkc, pkv, err := getPrimaryKeysAndValues(table, instance)
		if err != nil {
			return "", err
		}
		//sql += " WHERE " + table.Name + "." + pkc + "=" + pkv
		if len(pkc) > 0 {
			sql += " WHERE " + table.Name + "." + pkc[0] + "=" + pkv[0]
			for i := 1; i < len(pkc); i++ {
				sql += " AND " + table.Name + "." + pkc[i] + "=" + pkv[i]
			}
		}
	} else {
		sql += " WHERE " + where
	}
	//contraints are generated by relations between objects
	sql += relationContraints
	return sql, nil
}

//Find returns the TransientSQL sentence depending on the table and the instance
func (dialect *SQLDialect) Find(table models.Table, where string, instance interface{}) (string, error) {
	//SQL generated by entity
	sql, relationContraints, err := generateSQLQuery(table, dialect.Models)

	if err != nil {
		return "", err
	}

	if where == "" && len(relationContraints) > 5 {
		//contraints are generated by relations between objects
		sql += " WHERE " + relationContraints[5:]
	} else if where != "" {
		//where clause
		sql += " WHERE " + where
		sql += relationContraints
	}

	return sql, nil
}

//Update returns the TransientSQL sentence depending on the table and the instance
func (dialect *SQLDialect) Update(table models.Table, instance interface{}) (string, error) {
	columns, values, err := getColumnsAndValues(table, instance)
	if err != nil {
		return "", err
	}
	sql := "UPDATE " + table.Name + " SET "
	for i, column := range columns {
		sql += column + " = " + values[i] + ","
	}
	sql = sql[:len(sql)-1]
	pkc, pkv, err := getPrimaryKeysAndValues(table, instance)
	if err != nil {
		return "", errors.New("Error getting primary key")
	}
	//sql += " WHERE " + table.Name + "." + pkc + "=" + pkv
	if len(pkc) > 0 {
		sql += " WHERE " + table.Name + "." + pkc[0] + "=" + pkv[0]
		for i := 1; i < len(pkc); i++ {
			sql += " AND " + table.Name + "." + pkc[i] + "=" + pkv[i]
		}
	}
	return sql, nil
}

//Delete returns the TransientSQL sentence depending on the table and the instance
func (dialect *SQLDialect) Delete(table models.Table, where string, instance interface{}) (string, error) {
	sql := "DELETE FROM " + table.Name + " WHERE "
	if where == "" {
		pkc, pkv, err := getPrimaryKeysAndValues(table, instance)
		if err != nil {
			return "", err
		}
		//sql += pkc + "=" + pkv
		if len(pkc) > 0 {
			sql += pkc[0] + "=" + pkv[0]
			for i := 1; i < len(pkc); i++ {
				sql += " AND " + pkc[i] + "=" + pkv[i]
			}
		}
	} else {
		sql += where
	}
	return sql, nil
}

//Drop returns the TransientSQL sentence depending on the table and the instance
func (dialect *SQLDialect) Drop(tableName string) string {
	return "DROP TABLE " + tableName
}

func generateSQLQuery(table models.Table, modelMap map[string]models.Table) (query string, constraints string, err error) {
	query = "SELECT "
	from := " FROM " + table.Name + ","
	constraints = ""

	for _, column := range table.Columns {

		if column.Ignore {
			continue
		}

		if !column.IsComplex {
			query += table.Name + "." + column.Title + ","
			continue
		}
		referencedTable, ok := modelMap[column.ColumnTypeName]

		if !ok {
			err = errors.New("Model " + column.ColumnTypeName + " NOT FOUND")
		}

		for _, primaryKey := range referencedTable.PrimaryKeys {
			if primaryKey.Name == column.ForeignKey.ForeignKeyColumnReference {
				constraints += " AND " + table.Name + "." + column.Title + " = " + referencedTable.Name + "." + primaryKey.Name
				err = referenceSQLEntity(&from, &query, &constraints, referencedTable, modelMap)
			}
		}
	}
	//Removing last ','
	query = query[:len(query)-1] + from[:len(from)-1]
	return query, constraints, err
}

func referenceSQLEntity(from *string, query *string, constraints *string, table models.Table, modelMap map[string]models.Table) (err error) {
	*from += table.Name + ","
	for _, column := range table.Columns {

		if column.Ignore {
			continue
		}

		if !column.IsComplex {
			*query += table.Name + "." + column.Title + ","
			continue
		}

		referencedTable, ok := modelMap[column.ColumnTypeName]

		if !ok {
			return errors.New("Model " + column.ColumnTypeName + " NOT FOUND")
		}

		for _, primaryKey := range referencedTable.PrimaryKeys {
			if primaryKey.Name == column.ForeignKey.ForeignKeyColumnReference {
				*constraints += " AND " + table.Name + "." + column.Title + " = " + referencedTable.Name + "." + primaryKey.Name
				referenceSQLEntity(from, query, constraints, modelMap[column.ColumnTypeName], modelMap)
			}
		}
	}
	return err
}

func getPrimaryKeysAndValues(gt models.Table, obj interface{}) (columnName []string, columnValue []string, err error) {
	err = errors.New("No primary key found")
	val := reflect.ValueOf(obj)

	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}

	for i := 0; i < len(gt.Columns); i++ {
		v := val.Field(i)
		columnToAnalize := gt.Columns[i]
		if columnToAnalize.PrimaryKey {
			columnName = append(columnName, gt.Columns[i].Title)
			err = nil
			if columnToAnalize.IsComplex {
				columnValue = append(columnValue, getRelationPrimaryKeyValue(columnToAnalize, v))
			} else {
				columnValue = append(columnValue, getPrimaryKeyValue(columnToAnalize, v))
			}
		}
	}
	return columnName, columnValue, err
}

func getPrimaryKeyValue(columnToAnalize models.Column, v reflect.Value) (columnValue string) {
	switch columnToAnalize.ColumnType {
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int, reflect.Int64, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint, reflect.Uint64:
		columnValue = strconv.FormatInt(v.Int(), 10)
	case reflect.Float32, reflect.Float64:
		columnValue = strconv.FormatFloat(v.Float(), 'f', 6, 64)
	case reflect.Bool:
		if v.Bool() {
			columnValue = "1"
		} else {
			columnValue = "0"
		}
	case reflect.String:
		columnValue = "'" + v.String() + "'"
	}
	return columnValue
}

func getRelationPrimaryKeyValue(fkColumn models.Column, v reflect.Value) (columnValue string) {
	referencedFKColumn := v.FieldByName(fkColumn.ForeignKey.ForeignKeyColumnReference)

	switch fkColumn.ColumnType {
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int, reflect.Int64, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint, reflect.Uint64:
		columnValue = strconv.FormatInt(referencedFKColumn.Int(), 10)
	case reflect.Float32, reflect.Float64:
		columnValue = strconv.FormatFloat(referencedFKColumn.Float(), 'f', 6, 64)
	case reflect.Bool:
		if v.Bool() {
			columnValue = "1"
		} else {
			columnValue = "0"
		}
	case reflect.String:
		columnValue = "'" + referencedFKColumn.String() + "'"
	}
	return columnValue
}

func getColumnsAndValues(table models.Table, instance interface{}) (columns []string, values []string, err error) {
	instanceType := models.GetType(instance)
	intanceValue := models.GetValue(instance)

	for i := 0; i < len(table.Columns); i++ {
		var value reflect.Value

		if table.Columns[i].Ignore {
			continue
		}

		if table.Columns[i].AutoIncrement {
			continue
		}

		if table.Columns[i].IsComplex {
			//_, value, err = GetGoedbTagTypeAndValueOfIndexField(instanceType, intanceValue, "pk", i)
			complexType := instanceType.Field(i).Type
			complexValue := intanceValue.Field(i)
			_, value, err = models.GetGoedbTagTypeAndValueOfForeignKeyReference(complexType, complexValue, "pk,unique", table.Columns[i].ForeignKey)
			if err != nil {
				return columns, values, err
			}
		} else {
			value = intanceValue.Field(i)
		}

		switch table.Columns[i].ColumnType {
		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int, reflect.Int64, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint, reflect.Uint64:
			//values += strconv.FormatInt(value.Int(), 10) + ","
			values = append(values, strconv.FormatInt(value.Int(), 10))
		case reflect.Float32, reflect.Float64:
			//values += strconv.FormatFloat(value.Float(), 'f', 6, 64) + ","
			values = append(values, strconv.FormatFloat(value.Float(), 'f', 6, 64))
		case reflect.Bool:
			if value.Bool() {
				//values += "1,"
				values = append(values, "1")
			} else {
				//values += "0,"
				values = append(values, "0")
			}
		case reflect.String:
			//values += "'" + value.String() + "',"
			values = append(values, "'"+value.String()+"'")
		}
		//columns += metatable.Columns[i].Title + ","
		columns = append(columns, table.Columns[i].Title)
	}
	//return strCols[:len(strCols)-1], strValues[:len(strValues)-1], nil
	return columns, values, err
}
